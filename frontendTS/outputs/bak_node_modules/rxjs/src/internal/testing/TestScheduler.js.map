{"version":3,"file":"TestScheduler.js","sourceRoot":"","sources":["../../../../../../bak_node_modules/rxjs/src/internal/testing/TestScheduler.ts"],"names":[],"mappings":";;;AAAA,8CAA2C;AAC3C,qDAAkD;AAClD,mDAAgD;AAEhD,uDAAoD;AAEpD,4EAAwF;AAExF,oEAAsG;AACtG,8EAA2E;AAC3E,4FAAyF;AACzF,gFAA6E;AAE7E,sEAAmE;AACnE,oEAAiE;AACjE,kEAA+D;AAE/D,MAAM,eAAe,GAAW,GAAG,CAAC;AAqBpC,MAAa,aAAc,SAAQ,2CAAoB;IA8BrD;;;OAGG;IACH,YAAmB,eAA+D;QAChF,KAAK,CAAC,oCAAa,EAAE,eAAe,CAAC,CAAC;QADrB,oBAAe,GAAf,eAAe,CAAgD;QAzBlF;;WAEG;QACa,mBAAc,GAAyB,EAAE,CAAC;QAE1D;;WAEG;QACa,oBAAe,GAA0B,EAAE,CAAC;QAE5D;;WAEG;QACK,eAAU,GAAoB,EAAE,CAAC;QAEzC;;;WAGG;QACK,YAAO,GAAG,KAAK,CAAC;IAQxB,CAAC;IAED,UAAU,CAAC,OAAe;QACxB,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAClF,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE;YAClB,MAAM,IAAI,KAAK,CAAC,6DAA6D,CAAC,CAAC;SAChF;QACD,OAAO,OAAO,GAAG,aAAa,CAAC,eAAe,CAAC;IACjD,CAAC;IAED;;;;OAIG;IACH,oBAAoB,CAAa,OAAe,EAAE,MAAgC,EAAE,KAAW;QAC7F,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;SACxE;QACD,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC,CAAC;SAC1E;QACD,MAAM,QAAQ,GAAG,aAAa,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAC7F,MAAM,IAAI,GAAG,IAAI,+BAAc,CAAI,QAAQ,EAAE,IAAI,CAAC,CAAC;QACnD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChC,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;OAIG;IACH,mBAAmB,CAAa,OAAe,EAAE,MAAgC,EAAE,KAAW;QAC5F,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAC;SACzE;QACD,MAAM,QAAQ,GAAG,aAAa,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAC7F,MAAM,OAAO,GAAG,IAAI,6BAAa,CAAI,QAAQ,EAAE,IAAI,CAAC,CAAC;QACrD,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAClC,OAAO,OAAO,CAAC;IACjB,CAAC;IAEO,0BAA0B,CAAC,UAA2B,EAAE,UAAkB;QAChF,MAAM,QAAQ,GAAkB,EAAE,CAAC;QACnC,UAAU,CAAC,SAAS,CAAC;YACnB,IAAI,EAAE,CAAC,KAAK,EAAE,EAAE;gBACd,QAAQ,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,GAAG,UAAU,EAAE,YAAY,EAAE,IAAA,wCAAgB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAC3F,CAAC;YACD,KAAK,EAAE,CAAC,KAAK,EAAE,EAAE;gBACf,QAAQ,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,GAAG,UAAU,EAAE,YAAY,EAAE,IAAA,yCAAiB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAC5F,CAAC;YACD,QAAQ,EAAE,GAAG,EAAE;gBACb,QAAQ,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,GAAG,UAAU,EAAE,YAAY,EAAE,6CAAqB,EAAE,CAAC,CAAC;YACzF,CAAC;SACF,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,gBAAgB,CAAI,UAAyB,EAAE,sBAAqC,IAAI;QACtF,MAAM,MAAM,GAAkB,EAAE,CAAC;QACjC,MAAM,SAAS,GAAkB,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC;QAC1D,MAAM,kBAAkB,GAAG,aAAa,CAAC,2BAA2B,CAAC,mBAAmB,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QACxG,MAAM,iBAAiB,GAAG,kBAAkB,CAAC,eAAe,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,kBAAkB,CAAC,eAAe,CAAC;QACnH,MAAM,mBAAmB,GAAG,kBAAkB,CAAC,iBAAiB,CAAC;QACjE,IAAI,YAA0B,CAAC;QAE/B,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE;YACjB,YAAY,GAAG,UAAU,CAAC,SAAS,CAAC;gBAClC,IAAI,EAAE,CAAC,CAAC,EAAE,EAAE;oBACV,oCAAoC;oBACpC,MAAM,KAAK,GAAG,CAAC,YAAY,uBAAU,CAAC,CAAC,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC3F,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,YAAY,EAAE,IAAA,wCAAgB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;gBAC5E,CAAC;gBACD,KAAK,EAAE,CAAC,KAAK,EAAE,EAAE;oBACf,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,YAAY,EAAE,IAAA,yCAAiB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;gBAC7E,CAAC;gBACD,QAAQ,EAAE,GAAG,EAAE;oBACb,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,YAAY,EAAE,6CAAqB,EAAE,CAAC,CAAC;gBAC1E,CAAC;aACF,CAAC,CAAC;QACL,CAAC,EAAE,iBAAiB,CAAC,CAAC;QAEtB,IAAI,mBAAmB,KAAK,QAAQ,EAAE;YACpC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,EAAE,mBAAmB,CAAC,CAAC;SACtE;QAED,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAChC,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QAEzB,OAAO;YACL,IAAI,CAAC,OAAe,EAAE,MAAY,EAAE,UAAgB;gBAClD,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC;gBACvB,SAAS,CAAC,QAAQ,GAAG,aAAa,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;YAC9F,CAAC;YACD,OAAO,EAAE,CAAC,KAAoB,EAAE,EAAE;gBAChC,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC;gBACvB,SAAS,CAAC,QAAQ,GAAG,EAAE,CAAC;gBACxB,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE;oBACjB,YAAY,GAAG,KAAK,CAAC,SAAS,CAAC;wBAC7B,IAAI,EAAE,CAAC,CAAC,EAAE,EAAE;4BACV,oCAAoC;4BACpC,MAAM,KAAK,GAAG,CAAC,YAAY,uBAAU,CAAC,CAAC,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;4BAC3F,SAAS,CAAC,QAAS,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,YAAY,EAAE,IAAA,wCAAgB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;wBACzF,CAAC;wBACD,KAAK,EAAE,CAAC,KAAK,EAAE,EAAE;4BACf,SAAS,CAAC,QAAS,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,YAAY,EAAE,IAAA,yCAAiB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;wBAC1F,CAAC;wBACD,QAAQ,EAAE,GAAG,EAAE;4BACb,SAAS,CAAC,QAAS,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,YAAY,EAAE,6CAAqB,EAAE,CAAC,CAAC;wBACvF,CAAC;qBACF,CAAC,CAAC;gBACL,CAAC,EAAE,iBAAiB,CAAC,CAAC;YACxB,CAAC;SACF,CAAC;IACJ,CAAC;IAED,mBAAmB,CAAC,sBAAyC;QAC3D,MAAM,SAAS,GAAkB,EAAE,MAAM,EAAE,sBAAsB,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC;QAClF,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAChC,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QACzB,OAAO;YACL,IAAI,CAAC,qBAAwC;gBAC3C,MAAM,YAAY,GAAa,OAAO,qBAAqB,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC;gBAC3H,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC;gBACvB,SAAS,CAAC,QAAQ,GAAG,YAAY;qBAC9B,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,aAAa,CAAC,2BAA2B,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;qBAC7E,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,eAAe,KAAK,QAAQ,CAAC,CAAC;YAC/D,CAAC;SACF,CAAC;IACJ,CAAC;IAED,KAAK;QACH,MAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;QAC3C,OAAO,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;YAChC,cAAc,CAAC,KAAK,EAAG,CAAC,KAAK,EAAE,CAAC;SACjC;QAED,KAAK,CAAC,KAAK,EAAE,CAAC;QAEd,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE;YAChD,IAAI,IAAI,CAAC,KAAK,EAAE;gBACd,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACjD,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACL,CAAC;IAED,kBAAkB;IAClB,MAAM,CAAC,2BAA2B,CAAC,OAAsB,EAAE,OAAO,GAAG,KAAK;QACxE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YAC/B,OAAO,IAAI,iCAAe,CAAC,QAAQ,CAAC,CAAC;SACtC;QACD,2EAA2E;QAC3E,qCAAqC;QACrC,MAAM,UAAU,GAAG,CAAC,GAAG,OAAO,CAAC,CAAC;QAChC,MAAM,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC;QAC9B,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC;QACpB,IAAI,iBAAiB,GAAG,QAAQ,CAAC;QACjC,IAAI,mBAAmB,GAAG,QAAQ,CAAC;QACnC,IAAI,KAAK,GAAG,CAAC,CAAC;QAEd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAC5B,IAAI,SAAS,GAAG,KAAK,CAAC;YACtB,MAAM,cAAc,GAAG,CAAC,KAAa,EAAE,EAAE;gBACvC,SAAS,IAAI,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC;YAC5C,CAAC,CAAC;YACF,MAAM,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YACxB,QAAQ,CAAC,EAAE;gBACT,KAAK,GAAG;oBACN,qCAAqC;oBACrC,IAAI,CAAC,OAAO,EAAE;wBACZ,cAAc,CAAC,CAAC,CAAC,CAAC;qBACnB;oBACD,MAAM;gBACR,KAAK,GAAG;oBACN,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,GAAG;oBACN,UAAU,GAAG,KAAK,CAAC;oBACnB,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,GAAG;oBACN,UAAU,GAAG,CAAC,CAAC,CAAC;oBAChB,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,GAAG;oBACN,IAAI,iBAAiB,KAAK,QAAQ,EAAE;wBAClC,MAAM,IAAI,KAAK,CAAC,6CAA6C,GAAG,qDAAqD,CAAC,CAAC;qBACxH;oBACD,iBAAiB,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC;oBACzD,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,GAAG;oBACN,IAAI,mBAAmB,KAAK,QAAQ,EAAE;wBACpC,MAAM,IAAI,KAAK,CAAC,+CAA+C,GAAG,qDAAqD,CAAC,CAAC;qBAC1H;oBACD,mBAAmB,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC;oBAC3D,MAAM;gBACR;oBACE,0BAA0B;oBAC1B,IAAI,OAAO,IAAI,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE;wBACjC,0DAA0D;wBAC1D,8CAA8C;wBAC9C,IAAI,CAAC,KAAK,CAAC,IAAI,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;4BACxC,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;4BAC5C,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,iCAAiC,CAAC,CAAC;4BAC9D,IAAI,KAAK,EAAE;gCACT,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;gCACzB,MAAM,QAAQ,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gCACtC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gCACtB,IAAI,YAAoB,CAAC;gCAEzB,QAAQ,IAAI,EAAE;oCACZ,KAAK,IAAI;wCACP,YAAY,GAAG,QAAQ,CAAC;wCACxB,MAAM;oCACR,KAAK,GAAG;wCACN,YAAY,GAAG,QAAQ,GAAG,IAAI,CAAC;wCAC/B,MAAM;oCACR,KAAK,GAAG;wCACN,YAAY,GAAG,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;wCACpC,MAAM;oCACR;wCACE,MAAM;iCACT;gCAED,cAAc,CAAC,YAAa,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC;gCACrD,MAAM;6BACP;yBACF;qBACF;oBAED,MAAM,IAAI,KAAK,CAAC,6CAA6C,GAAG,8CAA8C,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;aAC9H;YAED,KAAK,GAAG,SAAS,CAAC;SACnB;QAED,IAAI,mBAAmB,GAAG,CAAC,EAAE;YAC3B,OAAO,IAAI,iCAAe,CAAC,iBAAiB,CAAC,CAAC;SAC/C;aAAM;YACL,OAAO,IAAI,iCAAe,CAAC,iBAAiB,EAAE,mBAAmB,CAAC,CAAC;SACpE;IACH,CAAC;IAED,kBAAkB;IAClB,MAAM,CAAC,YAAY,CACjB,OAAe,EACf,MAAY,EACZ,UAAgB,EAChB,8BAAuC,KAAK,EAC5C,OAAO,GAAG,KAAK;QAEf,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,+CAA+C,GAAG,2BAA2B,CAAC,CAAC;SAChG;QACD,2EAA2E;QAC3E,qCAAqC;QACrC,MAAM,UAAU,GAAG,CAAC,GAAG,OAAO,CAAC,CAAC;QAChC,MAAM,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC;QAC9B,MAAM,YAAY,GAAkB,EAAE,CAAC;QACvC,MAAM,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAC5F,IAAI,KAAK,GAAG,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC;QACnE,MAAM,QAAQ,GACZ,OAAO,MAAM,KAAK,QAAQ;YACxB,CAAC,CAAC,CAAC,CAAM,EAAE,EAAE,CAAC,CAAC;YACf,CAAC,CAAC,CAAC,CAAM,EAAE,EAAE;gBACT,oCAAoC;gBACpC,IAAI,2BAA2B,IAAI,MAAM,CAAC,CAAC,CAAC,YAAY,+BAAc,EAAE;oBACtE,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;iBAC3B;gBACD,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;YACnB,CAAC,CAAC;QACR,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC;QAEpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAC5B,IAAI,SAAS,GAAG,KAAK,CAAC;YACtB,MAAM,cAAc,GAAG,CAAC,KAAa,EAAE,EAAE;gBACvC,SAAS,IAAI,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC;YAC5C,CAAC,CAAC;YAEF,IAAI,YAAqD,CAAC;YAC1D,MAAM,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YACxB,QAAQ,CAAC,EAAE;gBACT,KAAK,GAAG;oBACN,qCAAqC;oBACrC,IAAI,CAAC,OAAO,EAAE;wBACZ,cAAc,CAAC,CAAC,CAAC,CAAC;qBACnB;oBACD,MAAM;gBACR,KAAK,GAAG;oBACN,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,GAAG;oBACN,UAAU,GAAG,KAAK,CAAC;oBACnB,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,GAAG;oBACN,UAAU,GAAG,CAAC,CAAC,CAAC;oBAChB,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,GAAG;oBACN,YAAY,GAAG,6CAAqB,CAAC;oBACrC,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,GAAG;oBACN,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,GAAG;oBACN,YAAY,GAAG,IAAA,yCAAiB,EAAC,UAAU,IAAI,OAAO,CAAC,CAAC;oBACxD,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;gBACR;oBACE,uDAAuD;oBACvD,IAAI,OAAO,IAAI,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE;wBACjC,0DAA0D;wBAC1D,8CAA8C;wBAC9C,IAAI,CAAC,KAAK,CAAC,IAAI,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;4BACxC,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;4BAC5C,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,iCAAiC,CAAC,CAAC;4BAC9D,IAAI,KAAK,EAAE;gCACT,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;gCACzB,MAAM,QAAQ,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gCACtC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gCACtB,IAAI,YAAoB,CAAC;gCAEzB,QAAQ,IAAI,EAAE;oCACZ,KAAK,IAAI;wCACP,YAAY,GAAG,QAAQ,CAAC;wCACxB,MAAM;oCACR,KAAK,GAAG;wCACN,YAAY,GAAG,QAAQ,GAAG,IAAI,CAAC;wCAC/B,MAAM;oCACR,KAAK,GAAG;wCACN,YAAY,GAAG,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;wCACpC,MAAM;oCACR;wCACE,MAAM;iCACT;gCAED,cAAc,CAAC,YAAa,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC;gCACrD,MAAM;6BACP;yBACF;qBACF;oBAED,YAAY,GAAG,IAAA,wCAAgB,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC7C,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;aACT;YAED,IAAI,YAAY,EAAE;gBAChB,YAAY,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,YAAY,EAAE,CAAC,CAAC;aAClF;YAED,KAAK,GAAG,SAAS,CAAC;SACnB;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAEO,cAAc;QACpB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;SAC5D;QAED,uEAAuE;QACvE,0EAA0E;QAC1E,wEAAwE;QACxE,yEAAyE;QACzE,wEAAwE;QACxE,yEAAyE;QACzE,yEAAyE;QACzE,aAAa;QAEb,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,GAAkD,CAAC;QAEvD,MAAM,QAAQ,GAAG;YACf,qBAAqB,CAAC,QAA8B;gBAClD,IAAI,CAAC,GAAG,EAAE;oBACR,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;iBAC1D;gBACD,MAAM,MAAM,GAAG,EAAE,UAAU,CAAC;gBAC5B,GAAG,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;gBAC1B,OAAO,MAAM,CAAC;YAChB,CAAC;YACD,oBAAoB,CAAC,MAAc;gBACjC,IAAI,CAAC,GAAG,EAAE;oBACR,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;iBAC1D;gBACD,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACrB,CAAC;SACF,CAAC;QAEF,MAAM,OAAO,GAAG,CAAC,OAAe,EAAE,EAAE;YAClC,IAAI,GAAG,EAAE;gBACP,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;aAC7E;YACD,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;gBACxB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;aACzD;YACD,GAAG,GAAG,IAAI,GAAG,EAAgC,CAAC;YAC9C,MAAM,QAAQ,GAAG,aAAa,CAAC,YAAY,CAAC,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;YAC5F,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;gBAC9B,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE;oBACjB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;oBACvB,6DAA6D;oBAC7D,uDAAuD;oBACvD,oEAAoE;oBACpE,6DAA6D;oBAC7D,oEAAoE;oBACpE,MAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,GAAI,CAAC,MAAM,EAAE,CAAC,CAAC;oBAC5C,GAAI,CAAC,KAAK,EAAE,CAAC;oBACb,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;wBAChC,QAAQ,CAAC,GAAG,CAAC,CAAC;qBACf;gBACH,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;aACnB;QACH,CAAC,CAAC;QAEF,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;IAC/B,CAAC;IAEO,eAAe;QACrB,yEAAyE;QACzE,yEAAyE;QACzE,uEAAuE;QACvE,yEAAyE;QACzE,iEAAiE;QACjE,oEAAoE;QACpE,qEAAqE;QACrE,sEAAsE;QACtE,sEAAsE;QACtE,sBAAsB;QAEtB,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,MAAM,cAAc,GAAG,IAAI,GAAG,EAU3B,CAAC;QAEJ,MAAM,GAAG,GAAG,GAAG,EAAE;YACf,uEAAuE;YACvE,qEAAqE;YACrE,gCAAgC;YAChC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACvB,MAAM,gBAAgB,GAAG,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC;YAC7D,MAAM,mBAAmB,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC;YAC7E,MAAM,aAAa,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,IAAI,KAAK,WAAW,CAAC,CAAC;YACrF,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC5B,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;gBAC7C,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC9B,OAAO,EAAE,CAAC;gBACV,OAAO;aACR;YACD,MAAM,YAAY,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC;YACnF,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC3B,MAAM,gBAAgB,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;gBACzC,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,gBAAgB,CAAC;gBAC/C,gBAAgB,CAAC,GAAG,GAAG,GAAG,GAAG,QAAQ,CAAC;gBACtC,sEAAsE;gBACtE,sEAAsE;gBACtE,oDAAoD;gBACpD,gBAAgB,CAAC,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;gBAC7D,OAAO,EAAE,CAAC;gBACV,OAAO;aACR;YACD,MAAM,WAAW,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC;YACjF,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC1B,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC3C,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC9B,OAAO,EAAE,CAAC;gBACV,OAAO;aACR;YACD,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;QAC1D,CAAC,CAAC;QAEF,oEAAoE;QACpE,8DAA8D;QAC9D,EAAE;QACF,gEAAgE;QAChE,EAAE;QACF,gEAAgE;QAChE,EAAE;QACF,uEAAuE;QACvE,uEAAuE;QACvE,2EAA2E;QAC3E,kEAAkE;QAElE,MAAM,SAAS,GAAG;YAChB,YAAY,EAAE,CAAC,OAAmB,EAAE,EAAE;gBACpC,MAAM,MAAM,GAAG,EAAE,UAAU,CAAC;gBAC5B,cAAc,CAAC,GAAG,CAAC,MAAM,EAAE;oBACzB,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE;oBACf,QAAQ,EAAE,CAAC;oBACX,MAAM;oBACN,OAAO;oBACP,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC;oBACnC,IAAI,EAAE,WAAW;iBAClB,CAAC,CAAC;gBACH,OAAO,MAAM,CAAC;YAChB,CAAC;YACD,cAAc,EAAE,CAAC,MAAmB,EAAE,EAAE;gBACtC,MAAM,KAAK,GAAG,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBACzC,IAAI,KAAK,EAAE;oBACT,KAAK,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC;oBACjC,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;iBAC/B;YACH,CAAC;SACF,CAAC;QAEF,MAAM,QAAQ,GAAG;YACf,WAAW,EAAE,CAAC,OAAmB,EAAE,QAAQ,GAAG,CAAC,EAAE,EAAE;gBACjD,MAAM,MAAM,GAAG,EAAE,UAAU,CAAC;gBAC5B,cAAc,CAAC,GAAG,CAAC,MAAM,EAAE;oBACzB,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,QAAQ;oBAC1B,QAAQ;oBACR,MAAM;oBACN,OAAO;oBACP,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC;oBAC1C,IAAI,EAAE,UAAU;iBACjB,CAAC,CAAC;gBACH,OAAO,MAAM,CAAC;YAChB,CAAC;YACD,aAAa,EAAE,CAAC,MAAmB,EAAE,EAAE;gBACrC,MAAM,KAAK,GAAG,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBACzC,IAAI,KAAK,EAAE;oBACT,KAAK,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC;oBACjC,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;iBAC/B;YACH,CAAC;SACF,CAAC;QAEF,MAAM,OAAO,GAAG;YACd,UAAU,EAAE,CAAC,OAAmB,EAAE,QAAQ,GAAG,CAAC,EAAE,EAAE;gBAChD,MAAM,MAAM,GAAG,EAAE,UAAU,CAAC;gBAC5B,cAAc,CAAC,GAAG,CAAC,MAAM,EAAE;oBACzB,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,QAAQ;oBAC1B,QAAQ;oBACR,MAAM;oBACN,OAAO;oBACP,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC;oBAC1C,IAAI,EAAE,SAAS;iBAChB,CAAC,CAAC;gBACH,OAAO,MAAM,CAAC;YAChB,CAAC;YACD,YAAY,EAAE,CAAC,MAAmB,EAAE,EAAE;gBACpC,MAAM,KAAK,GAAG,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBACzC,IAAI,KAAK,EAAE;oBACT,KAAK,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC;oBACjC,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;iBAC/B;YACH,CAAC;SACF,CAAC;QAEF,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC;IAC1C,CAAC;IAED;;;;;;;OAOG;IACH,GAAG,CAAI,QAAoC;QACzC,MAAM,mBAAmB,GAAG,aAAa,CAAC,eAAe,CAAC;QAC1D,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC;QAErC,aAAa,CAAC,eAAe,GAAG,CAAC,CAAC;QAClC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACvC,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QAEzC,+CAAsB,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;QACpD,6CAAqB,CAAC,QAAQ,GAAG,IAAI,CAAC;QACtC,qCAAiB,CAAC,QAAQ,GAAG,SAAS,CAAC,SAAS,CAAC;QACjD,mCAAgB,CAAC,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC;QAC/C,iCAAe,CAAC,QAAQ,GAAG,SAAS,CAAC,OAAO,CAAC;QAC7C,2DAA4B,CAAC,QAAQ,GAAG,IAAI,CAAC;QAE7C,MAAM,OAAO,GAAe;YAC1B,IAAI,EAAE,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC;YAC1C,GAAG,EAAE,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC;YACxC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;YAC5B,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;YAChC,gBAAgB,EAAE,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC;YAClD,mBAAmB,EAAE,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC;YACxD,OAAO,EAAE,QAAQ,CAAC,OAAO;SAC1B,CAAC;QACF,IAAI;YACF,MAAM,GAAG,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;YAC9B,IAAI,CAAC,KAAK,EAAE,CAAC;YACb,OAAO,GAAG,CAAC;SACZ;gBAAS;YACR,aAAa,CAAC,eAAe,GAAG,mBAAmB,CAAC;YACpD,IAAI,CAAC,SAAS,GAAG,aAAa,CAAC;YAC/B,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;YACrB,+CAAsB,CAAC,QAAQ,GAAG,SAAS,CAAC;YAC5C,6CAAqB,CAAC,QAAQ,GAAG,SAAS,CAAC;YAC3C,qCAAiB,CAAC,QAAQ,GAAG,SAAS,CAAC;YACvC,mCAAgB,CAAC,QAAQ,GAAG,SAAS,CAAC;YACtC,iCAAe,CAAC,QAAQ,GAAG,SAAS,CAAC;YACrC,2DAA4B,CAAC,QAAQ,GAAG,SAAS,CAAC;SACnD;IACH,CAAC;;AA5oBD;;;;;GAKG;AACI,6BAAe,GAAG,EAAE,AAAL,CAAM;AAPjB,sCAAa","sourcesContent":["import { Observable } from '../Observable';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { TestMessage } from './TestMessage';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { Subscription } from '../Subscription';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { ObservableNotification } from '../types';\nimport { COMPLETE_NOTIFICATION, errorNotification, nextNotification } from '../NotificationFactories';\nimport { dateTimestampProvider } from '../scheduler/dateTimestampProvider';\nimport { performanceTimestampProvider } from '../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../scheduler/animationFrameProvider';\nimport type { TimerHandle } from '../scheduler/timerHandle';\nimport { immediateProvider } from '../scheduler/immediateProvider';\nimport { intervalProvider } from '../scheduler/intervalProvider';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\nconst defaultMaxFrame: number = 750;\n\nexport interface RunHelpers {\n  cold: typeof TestScheduler.prototype.createColdObservable;\n  hot: typeof TestScheduler.prototype.createHotObservable;\n  flush: typeof TestScheduler.prototype.flush;\n  time: typeof TestScheduler.prototype.createTime;\n  expectObservable: typeof TestScheduler.prototype.expectObservable;\n  expectSubscriptions: typeof TestScheduler.prototype.expectSubscriptions;\n  animate: (marbles: string) => void;\n}\n\ninterface FlushableTest {\n  ready: boolean;\n  actual?: any[];\n  expected?: any[];\n}\n\nexport type observableToBeFn = (marbles: string, values?: any, errorValue?: any) => void;\nexport type subscriptionLogsToBeFn = (marbles: string | string[]) => void;\n\nexport class TestScheduler extends VirtualTimeScheduler {\n  /**\n   * The number of virtual time units each character in a marble diagram represents. If\n   * the test scheduler is being used in \"run mode\", via the `run` method, this is temporarily\n   * set to `1` for the duration of the `run` block, then set back to whatever value it was.\n   * @nocollapse\n   */\n  static frameTimeFactor = 10;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public readonly hotObservables: HotObservable<any>[] = [];\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public readonly coldObservables: ColdObservable<any>[] = [];\n\n  /**\n   * Test meta data to be processed during `flush()`\n   */\n  private flushTests: FlushableTest[] = [];\n\n  /**\n   * Indicates whether the TestScheduler instance is operating in \"run mode\",\n   * meaning it's processing a call to `run()`\n   */\n  private runMode = false;\n\n  /**\n   *\n   * @param assertDeepEqual A function to set up your assertion for your test harness\n   */\n  constructor(public assertDeepEqual: (actual: any, expected: any) => boolean | void) {\n    super(VirtualAction, defaultMaxFrame);\n  }\n\n  createTime(marbles: string): number {\n    const indexOf = this.runMode ? marbles.trim().indexOf('|') : marbles.indexOf('|');\n    if (indexOf === -1) {\n      throw new Error('marble diagram for time should have a completion marker \"|\"');\n    }\n    return indexOf * TestScheduler.frameTimeFactor;\n  }\n\n  /**\n   * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.\n   * @param values Values to use for the letters in `marbles`. If omitted, the letters themselves are used.\n   * @param error The error to use for the `#` marble (if present).\n   */\n  createColdObservable<T = string>(marbles: string, values?: { [marble: string]: T }, error?: any): ColdObservable<T> {\n    if (marbles.indexOf('^') !== -1) {\n      throw new Error('cold observable cannot have subscription offset \"^\"');\n    }\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('cold observable cannot have unsubscription marker \"!\"');\n    }\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const cold = new ColdObservable<T>(messages, this);\n    this.coldObservables.push(cold);\n    return cold;\n  }\n\n  /**\n   * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.\n   * @param values Values to use for the letters in `marbles`. If omitted, the letters themselves are used.\n   * @param error The error to use for the `#` marble (if present).\n   */\n  createHotObservable<T = string>(marbles: string, values?: { [marble: string]: T }, error?: any): HotObservable<T> {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('hot observable cannot have unsubscription marker \"!\"');\n    }\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const subject = new HotObservable<T>(messages, this);\n    this.hotObservables.push(subject);\n    return subject;\n  }\n\n  private materializeInnerObservable(observable: Observable<any>, outerFrame: number): TestMessage[] {\n    const messages: TestMessage[] = [];\n    observable.subscribe({\n      next: (value) => {\n        messages.push({ frame: this.frame - outerFrame, notification: nextNotification(value) });\n      },\n      error: (error) => {\n        messages.push({ frame: this.frame - outerFrame, notification: errorNotification(error) });\n      },\n      complete: () => {\n        messages.push({ frame: this.frame - outerFrame, notification: COMPLETE_NOTIFICATION });\n      },\n    });\n    return messages;\n  }\n\n  expectObservable<T>(observable: Observable<T>, subscriptionMarbles: string | null = null) {\n    const actual: TestMessage[] = [];\n    const flushTest: FlushableTest = { actual, ready: false };\n    const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n    const subscriptionFrame = subscriptionParsed.subscribedFrame === Infinity ? 0 : subscriptionParsed.subscribedFrame;\n    const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n    let subscription: Subscription;\n\n    this.schedule(() => {\n      subscription = observable.subscribe({\n        next: (x) => {\n          // Support Observable-of-Observables\n          const value = x instanceof Observable ? this.materializeInnerObservable(x, this.frame) : x;\n          actual.push({ frame: this.frame, notification: nextNotification(value) });\n        },\n        error: (error) => {\n          actual.push({ frame: this.frame, notification: errorNotification(error) });\n        },\n        complete: () => {\n          actual.push({ frame: this.frame, notification: COMPLETE_NOTIFICATION });\n        },\n      });\n    }, subscriptionFrame);\n\n    if (unsubscriptionFrame !== Infinity) {\n      this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n    }\n\n    this.flushTests.push(flushTest);\n    const { runMode } = this;\n\n    return {\n      toBe(marbles: string, values?: any, errorValue?: any) {\n        flushTest.ready = true;\n        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n      },\n      toEqual: (other: Observable<T>) => {\n        flushTest.ready = true;\n        flushTest.expected = [];\n        this.schedule(() => {\n          subscription = other.subscribe({\n            next: (x) => {\n              // Support Observable-of-Observables\n              const value = x instanceof Observable ? this.materializeInnerObservable(x, this.frame) : x;\n              flushTest.expected!.push({ frame: this.frame, notification: nextNotification(value) });\n            },\n            error: (error) => {\n              flushTest.expected!.push({ frame: this.frame, notification: errorNotification(error) });\n            },\n            complete: () => {\n              flushTest.expected!.push({ frame: this.frame, notification: COMPLETE_NOTIFICATION });\n            },\n          });\n        }, subscriptionFrame);\n      },\n    };\n  }\n\n  expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]): { toBe: subscriptionLogsToBeFn } {\n    const flushTest: FlushableTest = { actual: actualSubscriptionLogs, ready: false };\n    this.flushTests.push(flushTest);\n    const { runMode } = this;\n    return {\n      toBe(marblesOrMarblesArray: string | string[]) {\n        const marblesArray: string[] = typeof marblesOrMarblesArray === 'string' ? [marblesOrMarblesArray] : marblesOrMarblesArray;\n        flushTest.ready = true;\n        flushTest.expected = marblesArray\n          .map((marbles) => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode))\n          .filter((marbles) => marbles.subscribedFrame !== Infinity);\n      },\n    };\n  }\n\n  flush() {\n    const hotObservables = this.hotObservables;\n    while (hotObservables.length > 0) {\n      hotObservables.shift()!.setup();\n    }\n\n    super.flush();\n\n    this.flushTests = this.flushTests.filter((test) => {\n      if (test.ready) {\n        this.assertDeepEqual(test.actual, test.expected);\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /** @nocollapse */\n  static parseMarblesAsSubscriptions(marbles: string | null, runMode = false): SubscriptionLog {\n    if (typeof marbles !== 'string') {\n      return new SubscriptionLog(Infinity);\n    }\n    // Spreading the marbles into an array leverages ES2015's support for emoji\n    // characters when iterating strings.\n    const characters = [...marbles];\n    const len = characters.length;\n    let groupStart = -1;\n    let subscriptionFrame = Infinity;\n    let unsubscriptionFrame = Infinity;\n    let frame = 0;\n\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n      const advanceFrameBy = (count: number) => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n      const c = characters[i];\n      switch (c) {\n        case ' ':\n          // Whitespace no longer advances time\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n          break;\n        case '-':\n          advanceFrameBy(1);\n          break;\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n        case '^':\n          if (subscriptionFrame !== Infinity) {\n            throw new Error(\"found a second subscription point '^' in a \" + 'subscription marble diagram. There can only be one.');\n          }\n          subscriptionFrame = groupStart > -1 ? groupStart : frame;\n          advanceFrameBy(1);\n          break;\n        case '!':\n          if (unsubscriptionFrame !== Infinity) {\n            throw new Error(\"found a second unsubscription point '!' in a \" + 'subscription marble diagram. There can only be one.');\n          }\n          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n        default:\n          // time progression syntax\n          if (runMode && c.match(/^[0-9]$/)) {\n            // Time progression must be preceded by at least one space\n            // if it's not at the beginning of the diagram\n            if (i === 0 || characters[i - 1] === ' ') {\n              const buffer = characters.slice(i).join('');\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs: number;\n\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n                  default:\n                    break;\n                }\n\n                advanceFrameBy(durationInMs! / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n\n          throw new Error(\"there can only be '^' and '!' markers in a \" + \"subscription marble diagram. Found instead '\" + c + \"'.\");\n      }\n\n      frame = nextFrame;\n    }\n\n    if (unsubscriptionFrame < 0) {\n      return new SubscriptionLog(subscriptionFrame);\n    } else {\n      return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n    }\n  }\n\n  /** @nocollapse */\n  static parseMarbles(\n    marbles: string,\n    values?: any,\n    errorValue?: any,\n    materializeInnerObservables: boolean = false,\n    runMode = false\n  ): TestMessage[] {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n    }\n    // Spreading the marbles into an array leverages ES2015's support for emoji\n    // characters when iterating strings.\n    const characters = [...marbles];\n    const len = characters.length;\n    const testMessages: TestMessage[] = [];\n    const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n    let frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n    const getValue =\n      typeof values !== 'object'\n        ? (x: any) => x\n        : (x: any) => {\n            // Support Observable-of-Observables\n            if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n              return values[x].messages;\n            }\n            return values[x];\n          };\n    let groupStart = -1;\n\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n      const advanceFrameBy = (count: number) => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n\n      let notification: ObservableNotification<any> | undefined;\n      const c = characters[i];\n      switch (c) {\n        case ' ':\n          // Whitespace no longer advances time\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n          break;\n        case '-':\n          advanceFrameBy(1);\n          break;\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n        case '|':\n          notification = COMPLETE_NOTIFICATION;\n          advanceFrameBy(1);\n          break;\n        case '^':\n          advanceFrameBy(1);\n          break;\n        case '#':\n          notification = errorNotification(errorValue || 'error');\n          advanceFrameBy(1);\n          break;\n        default:\n          // Might be time progression syntax, or a value literal\n          if (runMode && c.match(/^[0-9]$/)) {\n            // Time progression must be preceded by at least one space\n            // if it's not at the beginning of the diagram\n            if (i === 0 || characters[i - 1] === ' ') {\n              const buffer = characters.slice(i).join('');\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs: number;\n\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n                  default:\n                    break;\n                }\n\n                advanceFrameBy(durationInMs! / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n\n          notification = nextNotification(getValue(c));\n          advanceFrameBy(1);\n          break;\n      }\n\n      if (notification) {\n        testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification });\n      }\n\n      frame = nextFrame;\n    }\n    return testMessages;\n  }\n\n  private createAnimator() {\n    if (!this.runMode) {\n      throw new Error('animate() must only be used in run mode');\n    }\n\n    // The TestScheduler assigns a delegate to the provider that's used for\n    // requestAnimationFrame (rAF). The delegate works in conjunction with the\n    // animate run helper to coordinate the invocation of any rAF callbacks,\n    // that are effected within tests, with the animation frames specified by\n    // the test's author - in the marbles that are passed to the animate run\n    // helper. This allows the test's author to write deterministic tests and\n    // gives the author full control over when - or if - animation frames are\n    // 'painted'.\n\n    let lastHandle = 0;\n    let map: Map<number, FrameRequestCallback> | undefined;\n\n    const delegate = {\n      requestAnimationFrame(callback: FrameRequestCallback) {\n        if (!map) {\n          throw new Error('animate() was not called within run()');\n        }\n        const handle = ++lastHandle;\n        map.set(handle, callback);\n        return handle;\n      },\n      cancelAnimationFrame(handle: number) {\n        if (!map) {\n          throw new Error('animate() was not called within run()');\n        }\n        map.delete(handle);\n      },\n    };\n\n    const animate = (marbles: string) => {\n      if (map) {\n        throw new Error('animate() must not be called more than once within run()');\n      }\n      if (/[|#]/.test(marbles)) {\n        throw new Error('animate() must not complete or error');\n      }\n      map = new Map<number, FrameRequestCallback>();\n      const messages = TestScheduler.parseMarbles(marbles, undefined, undefined, undefined, true);\n      for (const message of messages) {\n        this.schedule(() => {\n          const now = this.now();\n          // Capture the callbacks within the queue and clear the queue\n          // before enumerating the callbacks, as callbacks might\n          // reschedule themselves. (And, yeah, we're using a Map to represent\n          // the queue, but the values are guaranteed to be returned in\n          // insertion order, so it's all good. Trust me, I've read the docs.)\n          const callbacks = Array.from(map!.values());\n          map!.clear();\n          for (const callback of callbacks) {\n            callback(now);\n          }\n        }, message.frame);\n      }\n    };\n\n    return { animate, delegate };\n  }\n\n  private createDelegates() {\n    // When in run mode, the TestScheduler provides alternate implementations\n    // of set/clearImmediate and set/clearInterval. These implementations are\n    // consumed by the scheduler implementations via the providers. This is\n    // done to effect deterministic asap and async scheduler behavior so that\n    // all of the schedulers are testable in 'run mode'. Prior to v7,\n    // delegation occurred at the scheduler level. That is, the asap and\n    // animation frame schedulers were identical in behavior to the async\n    // scheduler. Now, when in run mode, asap actions are prioritized over\n    // async actions and animation frame actions are coordinated using the\n    // animate run helper.\n\n    let lastHandle = 0;\n    const scheduleLookup = new Map<\n      TimerHandle,\n      {\n        due: number;\n        duration: number;\n        handle: TimerHandle;\n        handler: () => void;\n        subscription: Subscription;\n        type: 'immediate' | 'interval' | 'timeout';\n      }\n    >();\n\n    const run = () => {\n      // Whenever a scheduled run is executed, it must run a single immediate\n      // or interval action - with immediate actions being prioritized over\n      // interval and timeout actions.\n      const now = this.now();\n      const scheduledRecords = Array.from(scheduleLookup.values());\n      const scheduledRecordsDue = scheduledRecords.filter(({ due }) => due <= now);\n      const dueImmediates = scheduledRecordsDue.filter(({ type }) => type === 'immediate');\n      if (dueImmediates.length > 0) {\n        const { handle, handler } = dueImmediates[0];\n        scheduleLookup.delete(handle);\n        handler();\n        return;\n      }\n      const dueIntervals = scheduledRecordsDue.filter(({ type }) => type === 'interval');\n      if (dueIntervals.length > 0) {\n        const firstDueInterval = dueIntervals[0];\n        const { duration, handler } = firstDueInterval;\n        firstDueInterval.due = now + duration;\n        // The interval delegate must behave like setInterval, so run needs to\n        // be rescheduled. This will continue until the clearInterval delegate\n        // unsubscribes and deletes the handle from the map.\n        firstDueInterval.subscription = this.schedule(run, duration);\n        handler();\n        return;\n      }\n      const dueTimeouts = scheduledRecordsDue.filter(({ type }) => type === 'timeout');\n      if (dueTimeouts.length > 0) {\n        const { handle, handler } = dueTimeouts[0];\n        scheduleLookup.delete(handle);\n        handler();\n        return;\n      }\n      throw new Error('Expected a due immediate or interval');\n    };\n\n    // The following objects are the delegates that replace conventional\n    // runtime implementations with TestScheduler implementations.\n    //\n    // The immediate delegate is depended upon by the asapScheduler.\n    //\n    // The interval delegate is depended upon by the asyncScheduler.\n    //\n    // The timeout delegate is not depended upon by any scheduler, but it's\n    // included here because the onUnhandledError and onStoppedNotification\n    // configuration points use setTimeout to avoid producer interference. It's\n    // inclusion allows for the testing of these configuration points.\n\n    const immediate = {\n      setImmediate: (handler: () => void) => {\n        const handle = ++lastHandle;\n        scheduleLookup.set(handle, {\n          due: this.now(),\n          duration: 0,\n          handle,\n          handler,\n          subscription: this.schedule(run, 0),\n          type: 'immediate',\n        });\n        return handle;\n      },\n      clearImmediate: (handle: TimerHandle) => {\n        const value = scheduleLookup.get(handle);\n        if (value) {\n          value.subscription.unsubscribe();\n          scheduleLookup.delete(handle);\n        }\n      },\n    };\n\n    const interval = {\n      setInterval: (handler: () => void, duration = 0) => {\n        const handle = ++lastHandle;\n        scheduleLookup.set(handle, {\n          due: this.now() + duration,\n          duration,\n          handle,\n          handler,\n          subscription: this.schedule(run, duration),\n          type: 'interval',\n        });\n        return handle;\n      },\n      clearInterval: (handle: TimerHandle) => {\n        const value = scheduleLookup.get(handle);\n        if (value) {\n          value.subscription.unsubscribe();\n          scheduleLookup.delete(handle);\n        }\n      },\n    };\n\n    const timeout = {\n      setTimeout: (handler: () => void, duration = 0) => {\n        const handle = ++lastHandle;\n        scheduleLookup.set(handle, {\n          due: this.now() + duration,\n          duration,\n          handle,\n          handler,\n          subscription: this.schedule(run, duration),\n          type: 'timeout',\n        });\n        return handle;\n      },\n      clearTimeout: (handle: TimerHandle) => {\n        const value = scheduleLookup.get(handle);\n        if (value) {\n          value.subscription.unsubscribe();\n          scheduleLookup.delete(handle);\n        }\n      },\n    };\n\n    return { immediate, interval, timeout };\n  }\n\n  /**\n   * The `run` method performs the test in 'run mode' - in which schedulers\n   * used within the test automatically delegate to the `TestScheduler`. That\n   * is, in 'run mode' there is no need to explicitly pass a `TestScheduler`\n   * instance to observable creators or operators.\n   *\n   * @see {@link /guide/testing/marble-testing}\n   */\n  run<T>(callback: (helpers: RunHelpers) => T): T {\n    const prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n    const prevMaxFrames = this.maxFrames;\n\n    TestScheduler.frameTimeFactor = 1;\n    this.maxFrames = Infinity;\n    this.runMode = true;\n\n    const animator = this.createAnimator();\n    const delegates = this.createDelegates();\n\n    animationFrameProvider.delegate = animator.delegate;\n    dateTimestampProvider.delegate = this;\n    immediateProvider.delegate = delegates.immediate;\n    intervalProvider.delegate = delegates.interval;\n    timeoutProvider.delegate = delegates.timeout;\n    performanceTimestampProvider.delegate = this;\n\n    const helpers: RunHelpers = {\n      cold: this.createColdObservable.bind(this),\n      hot: this.createHotObservable.bind(this),\n      flush: this.flush.bind(this),\n      time: this.createTime.bind(this),\n      expectObservable: this.expectObservable.bind(this),\n      expectSubscriptions: this.expectSubscriptions.bind(this),\n      animate: animator.animate,\n    };\n    try {\n      const ret = callback(helpers);\n      this.flush();\n      return ret;\n    } finally {\n      TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n      this.maxFrames = prevMaxFrames;\n      this.runMode = false;\n      animationFrameProvider.delegate = undefined;\n      dateTimestampProvider.delegate = undefined;\n      immediateProvider.delegate = undefined;\n      intervalProvider.delegate = undefined;\n      timeoutProvider.delegate = undefined;\n      performanceTimestampProvider.delegate = undefined;\n    }\n  }\n}\n"]}