{"version":3,"file":"groupBy.js","sourceRoot":"","sources":["../../../../../../bak_node_modules/rxjs/src/internal/operators/groupBy.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { ObservableInput, Observer, OperatorFunction, SubjectLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\n\nexport interface BasicGroupByOptions<K, T> {\n  element?: undefined;\n  duration?: (grouped: GroupedObservable<K, T>) => ObservableInput<any>;\n  connector?: () => SubjectLike<T>;\n}\n\nexport interface GroupByOptionsWithElement<K, E, T> {\n  element: (value: T) => E;\n  duration?: (grouped: GroupedObservable<K, E>) => ObservableInput<any>;\n  connector?: () => SubjectLike<E>;\n}\n\nexport function groupBy<T, K>(key: (value: T) => K, options: BasicGroupByOptions<K, T>): OperatorFunction<T, GroupedObservable<K, T>>;\n\nexport function groupBy<T, K, E>(\n  key: (value: T) => K,\n  options: GroupByOptionsWithElement<K, E, T>\n): OperatorFunction<T, GroupedObservable<K, E>>;\n\nexport function groupBy<T, K extends T>(\n  key: (value: T) => value is K\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\n\nexport function groupBy<T, K>(key: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K>(\n  key: (value: T) => K,\n  element: void,\n  duration: (grouped: GroupedObservable<K, T>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * ![](groupBy.png)\n *\n * When the Observable emits an item, a key is computed for this item with the key function.\n *\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\n * {@link GroupedObservable} for this key is created and emits.\n *\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\n * key is available as the `key` field of a {@link GroupedObservable} instance.\n *\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\n * returned by the element function.\n *\n * ## Examples\n *\n * Group objects by `id` and return as array\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [{ id: 1, name: 'JavaScript' }, { id: 1, name: 'TypeScript'}]\n * // [{ id: 2, name: 'Parcel' }, { id: 2, name: 'webpack'}]\n * // [{ id: 3, name: 'TSLint' }]\n * ```\n *\n * Pivot data on the `id` field\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce, map } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id, { element: p => p.name }),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [`${ group$.key }`]))),\n *   map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\n * // { id: 3, values: [ 'TSLint' ] }\n * ```\n *\n * @param key A function that extracts the key\n * for each item.\n * @param element A function that extracts the\n * return element for each item.\n * @param duration\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @param connector Factory function to create an\n * intermediate Subject through which grouped elements are emitted.\n * @return A function that returns an Observable that emits GroupedObservables,\n * each of which corresponds to a unique key value and each of which emits\n * those items from the source Observable that share that key value.\n *\n * @deprecated Use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n  connector?: () => Subject<R>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n// Impl\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementOrOptions?: ((value: any) => any) | void | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>,\n  duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>,\n  connector?: () => SubjectLike<any>\n): OperatorFunction<T, GroupedObservable<K, R>> {\n  return operate((source, subscriber) => {\n    let element: ((value: any) => any) | void;\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions as ((value: any) => any);\n    } else {\n      ({ duration, element, connector } = elementOrOptions);\n    }\n\n    // A lookup for the groups that we have so far.\n    const groups = new Map<K, SubjectLike<any>>();\n\n    // Used for notifying all groups and the subscriber in the same way.\n    const notify = (cb: (group: Observer<any>) => void) => {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    // Used to handle errors from the source, AND errors that occur during the\n    // next call from the source.\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\n\n    // The number of actively subscribed groups\n    let activeGroups = 0;\n\n    // Whether or not teardown was attempted on this subscription.\n    let teardownAttempted = false;\n\n    // Capturing a reference to this, because we need a handle to it\n    // in `createGroupedObservable` below. This is what we use to\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\n    // in cases where a user unsubscribes from the main resulting subscription, but\n    // still has groups from this subscription subscribed and would expect values from it\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\n    const groupBySourceSubscriber = new OperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Because we have to notify all groups of any errors that occur in here,\n        // we have to add our own try/catch to ensure that those errors are propagated.\n        // OperatorSubscriber will only send the error to the main subscriber.\n        try {\n          const key = keySelector(value);\n\n          let group = groups.get(key);\n          if (!group) {\n            // Create our group subject\n            groups.set(key, (group = connector ? connector() : new Subject<any>()));\n\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\n            // because the grouped observable has special semantics around reference counting\n            // to ensure we don't sever our connection to the source prematurely.\n            const grouped = createGroupedObservable(key, group);\n            subscriber.next(grouped);\n\n            if (duration) {\n              const durationSubscriber = createOperatorSubscriber(\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\n                // when the duration subscription is torn down. That is important, because then\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\n                // after the connection to the source has been severed, they will get an\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\n                group as any,\n                () => {\n                  // Our duration notified! We can complete the group.\n                  // The group will be removed from the map in the finalization phase.\n                  group!.complete();\n                  durationSubscriber?.unsubscribe();\n                },\n                // Completions are also sent to the group, but just the group.\n                undefined,\n                // Errors on the duration subscriber are sent to the group\n                // but only the group. They are not sent to the main subscription.\n                undefined,\n                // Finalization: Remove this group from our map.\n                () => groups.delete(key)\n              );\n\n              // Start our duration notifier.\n              groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n            }\n          }\n\n          // Send the value to our group.\n          group.next(element ? element(value) : value);\n        } catch (err) {\n          handleError(err);\n        }\n      },\n      // Source completes.\n      () => notify((consumer) => consumer.complete()),\n      // Error from the source.\n      handleError,\n      // Free up memory.\n      // When the source subscription is _finally_ torn down, release the subjects and keys\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\n      // don't have to.\n      () => groups.clear(),\n      () => {\n        teardownAttempted = true;\n        // We only kill our subscription to the source if we have\n        // no active groups. As stated above, consider this scenario:\n        // source$.pipe(groupBy(fn), take(2)).\n        return activeGroups === 0;\n      }\n    );\n\n    // Subscribe to the source\n    source.subscribe(groupBySourceSubscriber);\n\n    /**\n     * Creates the actual grouped observable returned.\n     * @param key The key of the group\n     * @param groupSubject The subject that fuels the group\n     */\n    function createGroupedObservable(key: K, groupSubject: SubjectLike<any>) {\n      const result: any = new Observable<T>((groupSubscriber) => {\n        activeGroups++;\n        const innerSub = groupSubject.subscribe(groupSubscriber);\n        return () => {\n          innerSub.unsubscribe();\n          // We can kill the subscription to our source if we now have no more\n          // active groups subscribed, and a finalization was already attempted on\n          // the source.\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\n\n/**\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\n * contains a `key` property for the grouping.\n */\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  /**\n   * The key value for the grouped notifications.\n   */\n  readonly key: K;\n}\n"]}