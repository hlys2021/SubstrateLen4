{"version":3,"file":"fetch.js","sourceRoot":"","sources":["../../../../../../../bak_node_modules/rxjs/src/internal/observable/dom/fetch.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,2EAA8E;AAC9E,iDAA8C;AAC9C,0DAAuD;AAYvD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+EG;AACH,SAAgB,SAAS,CACvB,KAAuB,EACvB,mBAEI,EAAE;IAEN,MAAM,EAAE,QAAQ,KAAc,gBAAgB,EAAzB,IAAI,UAAK,gBAAgB,EAAxC,YAAqB,CAAmB,CAAC;IAC/C,OAAO,IAAI,uBAAU,CAAe,CAAC,UAAU,EAAE,EAAE;QACjD,0CAA0C;QAC1C,wDAAwD;QACxD,sDAAsD;QACtD,kEAAkE;QAClE,MAAM,UAAU,GAAG,IAAI,eAAe,EAAE,CAAC;QACzC,MAAM,EAAE,MAAM,EAAE,GAAG,UAAU,CAAC;QAC9B,+EAA+E;QAC/E,4EAA4E;QAC5E,6EAA6E;QAC7E,sFAAsF;QACtF,IAAI,SAAS,GAAG,IAAI,CAAC;QAErB,qDAAqD;QACrD,8DAA8D;QAC9D,yFAAyF;QACzF,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;QACrC,IAAI,WAAW,EAAE;YACf,IAAI,WAAW,CAAC,OAAO,EAAE;gBACvB,UAAU,CAAC,KAAK,EAAE,CAAC;aACpB;iBAAM;gBACL,oEAAoE;gBACpE,2EAA2E;gBAC3E,MAAM,kBAAkB,GAAG,GAAG,EAAE;oBAC9B,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;wBACnB,UAAU,CAAC,KAAK,EAAE,CAAC;qBACpB;gBACH,CAAC,CAAC;gBACF,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;gBAC1D,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,WAAW,CAAC,mBAAmB,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC,CAAC;aACpF;SACF;QAED,4DAA4D;QAC5D,iEAAiE;QACjE,sEAAsE;QACtE,kEAAkE;QAClE,qDAAqD;QACrD,MAAM,iBAAiB,mCAAqB,IAAI,KAAE,MAAM,GAAE,CAAC;QAE3D,MAAM,WAAW,GAAG,CAAC,GAAQ,EAAE,EAAE;YAC/B,SAAS,GAAG,KAAK,CAAC;YAClB,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACxB,CAAC,CAAC;QAEF,KAAK,CAAC,KAAK,EAAE,iBAAiB,CAAC;aAC5B,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE;YACjB,IAAI,QAAQ,EAAE;gBACZ,kEAAkE;gBAClE,2DAA2D;gBAC3D,iDAAiD;gBACjD,IAAA,qBAAS,EAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CACrC,IAAA,6CAAwB,EACtB,UAAU;gBACV,8CAA8C;gBAC9C,SAAS;gBACT,sCAAsC;gBACtC,GAAG,EAAE;oBACH,SAAS,GAAG,KAAK,CAAC;oBAClB,UAAU,CAAC,QAAQ,EAAE,CAAC;gBACxB,CAAC,EACD,WAAW,CACZ,CACF,CAAC;aACH;iBAAM;gBACL,SAAS,GAAG,KAAK,CAAC;gBAClB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC1B,UAAU,CAAC,QAAQ,EAAE,CAAC;aACvB;QACH,CAAC,CAAC;aACD,KAAK,CAAC,WAAW,CAAC,CAAC;QAEtB,OAAO,GAAG,EAAE;YACV,IAAI,SAAS,EAAE;gBACb,UAAU,CAAC,KAAK,EAAE,CAAC;aACpB;QACH,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AArFD,8BAqFC","sourcesContent":["import { createOperatorSubscriber } from '../../operators/OperatorSubscriber';\nimport { Observable } from '../../Observable';\nimport { innerFrom } from '../../observable/innerFrom';\nimport { ObservableInput } from '../../types';\n\nexport function fromFetch<T>(\n  input: string | Request,\n  init: RequestInit & {\n    selector: (response: Response) => ObservableInput<T>;\n  }\n): Observable<T>;\n\nexport function fromFetch(input: string | Request, init?: RequestInit): Observable<Response>;\n\n/**\n * Uses [the Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) to\n * make an HTTP request.\n *\n * **WARNING** Parts of the fetch API are still experimental. `AbortController` is\n * required for this implementation to work and use cancellation appropriately.\n *\n * Will automatically set up an internal [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\n * in order to finalize the internal `fetch` when the subscription tears down.\n *\n * If a `signal` is provided via the `init` argument, it will behave like it usually does with\n * `fetch`. If the provided `signal` aborts, the error that `fetch` normally rejects with\n * in that scenario will be emitted as an error from the observable.\n *\n * ## Examples\n *\n * Basic use\n *\n * ```ts\n * import { fromFetch } from 'rxjs/fetch';\n * import { switchMap, of, catchError } from 'rxjs';\n *\n * const data$ = fromFetch('https://api.github.com/users?per_page=5').pipe(\n *   switchMap(response => {\n *     if (response.ok) {\n *       // OK return data\n *       return response.json();\n *     } else {\n *       // Server is returning a status requiring the client to try something else.\n *       return of({ error: true, message: `Error ${ response.status }` });\n *     }\n *   }),\n *   catchError(err => {\n *     // Network or other error, handle appropriately\n *     console.error(err);\n *     return of({ error: true, message: err.message })\n *   })\n * );\n *\n * data$.subscribe({\n *   next: result => console.log(result),\n *   complete: () => console.log('done')\n * });\n * ```\n *\n * ### Use with Chunked Transfer Encoding\n *\n * With HTTP responses that use [chunked transfer encoding](https://tools.ietf.org/html/rfc7230#section-3.3.1),\n * the promise returned by `fetch` will resolve as soon as the response's headers are\n * received.\n *\n * That means the `fromFetch` observable will emit a `Response` - and will\n * then complete - before the body is received. When one of the methods on the\n * `Response` - like `text()` or `json()` - is called, the returned promise will not\n * resolve until the entire body has been received. Unsubscribing from any observable\n * that uses the promise as an observable input will not abort the request.\n *\n * To facilitate aborting the retrieval of responses that use chunked transfer encoding,\n * a `selector` can be specified via the `init` parameter:\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { fromFetch } from 'rxjs/fetch';\n *\n * const data$ = fromFetch('https://api.github.com/users?per_page=5', {\n *   selector: response => response.json()\n * });\n *\n * data$.subscribe({\n *   next: result => console.log(result),\n *   complete: () => console.log('done')\n * });\n * ```\n *\n * @param input The resource you would like to fetch. Can be a url or a request object.\n * @param initWithSelector A configuration object for the fetch.\n * [See MDN for more details](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n * @returns An Observable, that when subscribed to, performs an HTTP request using the native `fetch`\n * function. The {@link Subscription} is tied to an `AbortController` for the fetch.\n */\nexport function fromFetch<T>(\n  input: string | Request,\n  initWithSelector: RequestInit & {\n    selector?: (response: Response) => ObservableInput<T>;\n  } = {}\n): Observable<Response | T> {\n  const { selector, ...init } = initWithSelector;\n  return new Observable<Response | T>((subscriber) => {\n    // Our controller for aborting this fetch.\n    // Any externally provided AbortSignal will have to call\n    // abort on this controller when signaled, because the\n    // signal from this controller is what is being passed to `fetch`.\n    const controller = new AbortController();\n    const { signal } = controller;\n    // This flag exists to make sure we don't `abort()` the fetch upon tearing down\n    // this observable after emitting a Response. Aborting in such circumstances\n    // would also abort subsequent methods - like `json()` - that could be called\n    // on the Response. Consider: `fromFetch().pipe(take(1), mergeMap(res => res.json()))`\n    let abortable = true;\n\n    // If the user provided an init configuration object,\n    // let's process it and chain our abort signals, if necessary.\n    // If a signal is provided, just have it finalized. It's a cancellation token, basically.\n    const { signal: outerSignal } = init;\n    if (outerSignal) {\n      if (outerSignal.aborted) {\n        controller.abort();\n      } else {\n        // We got an AbortSignal from the arguments passed into `fromFetch`.\n        // We need to wire up our AbortController to abort when this signal aborts.\n        const outerSignalHandler = () => {\n          if (!signal.aborted) {\n            controller.abort();\n          }\n        };\n        outerSignal.addEventListener('abort', outerSignalHandler);\n        subscriber.add(() => outerSignal.removeEventListener('abort', outerSignalHandler));\n      }\n    }\n\n    // The initialization object passed to `fetch` as the second\n    // argument. This ferries in important information, including our\n    // AbortSignal. Create a new init, so we don't accidentally mutate the\n    // passed init, or reassign it. This is because the init passed in\n    // is shared between each subscription to the result.\n    const perSubscriberInit: RequestInit = { ...init, signal };\n\n    const handleError = (err: any) => {\n      abortable = false;\n      subscriber.error(err);\n    };\n\n    fetch(input, perSubscriberInit)\n      .then((response) => {\n        if (selector) {\n          // If we have a selector function, use it to project our response.\n          // Note that any error that comes from our selector will be\n          // sent to the promise `catch` below and handled.\n          innerFrom(selector(response)).subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              // Values are passed through to the subscriber\n              undefined,\n              // The projected response is complete.\n              () => {\n                abortable = false;\n                subscriber.complete();\n              },\n              handleError\n            )\n          );\n        } else {\n          abortable = false;\n          subscriber.next(response);\n          subscriber.complete();\n        }\n      })\n      .catch(handleError);\n\n    return () => {\n      if (abortable) {\n        controller.abort();\n      }\n    };\n  });\n}\n"]}