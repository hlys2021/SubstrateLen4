{"version":3,"file":"AsyncScheduler.js","sourceRoot":"","sources":["../../../../../../bak_node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts"],"names":[],"mappings":";;;AAAA,4CAAyC;AAKzC,MAAa,cAAe,SAAQ,qBAAS;IAkB3C,YAAY,eAA8B,EAAE,MAAoB,qBAAS,CAAC,GAAG;QAC3E,KAAK,CAAC,eAAe,EAAE,GAAG,CAAC,CAAC;QAlBvB,YAAO,GAA4B,EAAE,CAAC;QAC7C;;;;;WAKG;QACI,YAAO,GAAY,KAAK,CAAC;IAYhC,CAAC;IAEM,KAAK,CAAC,MAAwB;QACnC,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QAEzB,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACrB,OAAO;SACR;QAED,IAAI,KAAU,CAAC;QACf,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,GAAG;YACD,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;gBACxD,MAAM;aACP;SACF,QAAQ,CAAC,MAAM,GAAG,OAAO,CAAC,KAAK,EAAG,CAAC,EAAE,CAAC,8BAA8B;QAErE,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QAErB,IAAI,KAAK,EAAE;YACT,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,KAAK,EAAG,CAAC,EAAE;gBAClC,MAAM,CAAC,WAAW,EAAE,CAAC;aACtB;YACD,MAAM,KAAK,CAAC;SACb;IACH,CAAC;CACF;AAhDD,wCAgDC","sourcesContent":["import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n"]}