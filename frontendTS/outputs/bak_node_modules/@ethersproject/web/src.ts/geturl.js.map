{"version":3,"file":"geturl.js","sourceRoot":"","sources":["../../../../../bak_node_modules/@ethersproject/web/src.ts/geturl.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\nimport { parse } from \"url\"\n\nimport { arrayify, concat } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { GetUrlResponse, Options };\n\nfunction getResponse(request: http.ClientRequest): Promise<GetUrlResponse> {\n    return new Promise((resolve, reject) => {\n        request.once(\"response\", (resp: http.IncomingMessage) => {\n            const response: GetUrlResponse = {\n                statusCode: resp.statusCode,\n                statusMessage: resp.statusMessage,\n                headers: Object.keys(resp.headers).reduce((accum, name) => {\n                    let value = resp.headers[name];\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, <{ [ name: string ]: string }>{ }),\n                body: null\n            };\n            //resp.setEncoding(\"utf8\");\n\n            resp.on(\"data\", (chunk: Uint8Array) => {\n                if (response.body == null) { response.body = new Uint8Array(0); }\n                response.body = concat([ response.body, chunk ]);\n            });\n\n            resp.on(\"end\", () => {\n                if (response.headers[\"content-encoding\"] === \"gzip\") {\n                    //const size = response.body.length;\n                    response.body = arrayify(gunzipSync(response.body));\n                    //console.log(\"Delta:\", response.body.length - size, Buffer.from(response.body).toString());\n                }\n                resolve(response);\n            });\n\n            resp.on(\"error\", (error) => {\n                /* istanbul ignore next */\n                (<any>error).response = response;\n                reject(error);\n            });\n        });\n\n        request.on(\"error\", (error) => { reject(error); });\n    });\n}\n\n// The URL.parse uses null instead of the empty string\nfunction nonnull(value: string): string {\n    if (value == null) { return \"\"; }\n    return value;\n}\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    // @TODO: Once we drop support for node 8, we can pass the href\n    //        directly into request and skip adding the components\n    //        to this request object\n    const url = parse(href);\n\n    const request = {\n        protocol: nonnull(url.protocol),\n        hostname: nonnull(url.hostname),\n        port: nonnull(url.port),\n        path: (nonnull(url.pathname) + nonnull(url.search)),\n\n        method: (options.method || \"GET\"),\n        headers: shallowCopy(options.headers || { }),\n    };\n\n    if (options.allowGzip) {\n        request.headers[\"accept-encoding\"] = \"gzip\";\n    }\n\n    let req: http.ClientRequest = null;\n    switch (nonnull(url.protocol)) {\n        case \"http:\":\n            req = http.request(request);\n            break;\n        case \"https:\":\n            req = https.request(request);\n            break;\n        default:\n            /* istanbul ignore next */\n            logger.throwError(`unsupported protocol ${ url.protocol }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                protocol: url.protocol,\n                operation: \"request\"\n            });\n    }\n\n    if (options.body) {\n        req.write(Buffer.from(options.body));\n    }\n    req.end();\n\n    const response = await getResponse(req);\n    return response;\n}\n\n"]}