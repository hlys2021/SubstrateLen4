{"version":3,"file":"hdkey-secp256k1v3.js","sourceRoot":"","sources":["../../../../../bak_node_modules/ethereum-cryptography/src/shims/hdkey-secp256k1v3.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qDAAuC;AAEvC,SAAgB,gBAAgB,CAAC,UAAkB;IACjD,OAAO,SAAS,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;AAChD,CAAC;AAFD,4CAEC;AAED,SAAgB,eAAe,CAAC,UAAkB,EAAE,UAAU,GAAG,IAAI;IACnE,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC;AACxE,CAAC;AAFD,0CAEC;AAED,SAAgB,eAAe,CAAC,SAAiB;IAC/C,OAAO,SAAS,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;AAC9C,CAAC;AAFD,0CAEC;AAED,SAAgB,gBAAgB,CAAC,SAAiB,EAAE,UAAU,GAAG,IAAI;IACnE,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC,CAAC;AACxE,CAAC;AAFD,4CAEC;AAED,SAAgB,kBAAkB,CAAC,SAAiB,EAAE,KAAa;IACjE,OAAO,MAAM,CAAC,IAAI,CAChB,SAAS,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,KAAK,CAAC,CAC5D,CAAC;AACJ,CAAC;AAJD,gDAIC;AAED,SAAgB,iBAAiB,CAC/B,SAAiB,EACjB,KAAa,EACb,UAAU,GAAG,IAAI;IAEjB,OAAO,MAAM,CAAC,IAAI,CAChB,SAAS,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,KAAK,EAAE,UAAU,CAAC,CACvE,CAAC;AACJ,CAAC;AARD,8CAQC;AAED,SAAgB,IAAI,CAClB,OAAe,EACf,UAAkB;IAElB,MAAM,GAAG,GAAG,SAAS,CAAC,SAAS,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;IACrD,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,EAAE,CAAC;AACxE,CAAC;AAND,oBAMC;AAED,SAAgB,MAAM,CACpB,OAAe,EACf,SAAiB,EACjB,SAAiB;IAEjB,OAAO,SAAS,CAAC,WAAW,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;AAC9D,CAAC;AAND,wBAMC","sourcesContent":["import * as secp256k1 from \"secp256k1\";\n\nexport function privateKeyVerify(privateKey: Buffer): boolean {\n  return secp256k1.privateKeyVerify(privateKey);\n}\n\nexport function publicKeyCreate(privateKey: Buffer, compressed = true): Buffer {\n  return Buffer.from(secp256k1.publicKeyCreate(privateKey, compressed));\n}\n\nexport function publicKeyVerify(publicKey: Buffer): boolean {\n  return secp256k1.publicKeyVerify(publicKey);\n}\n\nexport function publicKeyConvert(publicKey: Buffer, compressed = true): Buffer {\n  return Buffer.from(secp256k1.publicKeyConvert(publicKey, compressed));\n}\n\nexport function privateKeyTweakAdd(publicKey: Buffer, tweak: Buffer): Buffer {\n  return Buffer.from(\n    secp256k1.privateKeyTweakAdd(Buffer.from(publicKey), tweak)\n  );\n}\n\nexport function publicKeyTweakAdd(\n  publicKey: Buffer,\n  tweak: Buffer,\n  compressed = true\n): Buffer {\n  return Buffer.from(\n    secp256k1.publicKeyTweakAdd(Buffer.from(publicKey), tweak, compressed)\n  );\n}\n\nexport function sign(\n  message: Buffer,\n  privateKey: Buffer\n): { signature: Buffer; recovery: number } {\n  const ret = secp256k1.ecdsaSign(message, privateKey);\n  return { signature: Buffer.from(ret.signature), recovery: ret.recid };\n}\n\nexport function verify(\n  message: Buffer,\n  signature: Buffer,\n  publicKey: Buffer\n): boolean {\n  return secp256k1.ecdsaVerify(signature, message, publicKey);\n}\n"]}