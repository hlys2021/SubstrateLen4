{"version":3,"file":"account.js","sourceRoot":"","sources":["../../../../bak_node_modules/ethereumjs-util/src/account.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from 'assert'\nimport { BN, rlp } from './externals'\nimport {\n  privateKeyVerify,\n  publicKeyCreate,\n  publicKeyVerify,\n  publicKeyConvert,\n} from 'ethereum-cryptography/secp256k1'\nimport { stripHexPrefix } from './internal'\nimport { KECCAK256_RLP, KECCAK256_NULL } from './constants'\nimport { zeros, bufferToHex, toBuffer } from './bytes'\nimport { keccak, keccak256, keccakFromString, rlphash } from './hash'\nimport { assertIsString, assertIsHexString, assertIsBuffer } from './helpers'\nimport { BNLike, BufferLike, bnToUnpaddedBuffer, toType, TypeOutput } from './types'\n\nexport interface AccountData {\n  nonce?: BNLike\n  balance?: BNLike\n  stateRoot?: BufferLike\n  codeHash?: BufferLike\n}\n\nexport class Account {\n  nonce: BN\n  balance: BN\n  stateRoot: Buffer\n  codeHash: Buffer\n\n  static fromAccountData(accountData: AccountData) {\n    const { nonce, balance, stateRoot, codeHash } = accountData\n\n    return new Account(\n      nonce ? new BN(toBuffer(nonce)) : undefined,\n      balance ? new BN(toBuffer(balance)) : undefined,\n      stateRoot ? toBuffer(stateRoot) : undefined,\n      codeHash ? toBuffer(codeHash) : undefined\n    )\n  }\n\n  public static fromRlpSerializedAccount(serialized: Buffer) {\n    const values = rlp.decode(serialized)\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array')\n    }\n\n    return this.fromValuesArray(values)\n  }\n\n  public static fromValuesArray(values: Buffer[]) {\n    const [nonce, balance, stateRoot, codeHash] = values\n\n    return new Account(new BN(nonce), new BN(balance), stateRoot, codeHash)\n  }\n\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor(\n    nonce = new BN(0),\n    balance = new BN(0),\n    stateRoot = KECCAK256_RLP,\n    codeHash = KECCAK256_NULL\n  ) {\n    this.nonce = nonce\n    this.balance = balance\n    this.stateRoot = stateRoot\n    this.codeHash = codeHash\n\n    this._validate()\n  }\n\n  private _validate() {\n    if (this.nonce.lt(new BN(0))) {\n      throw new Error('nonce must be greater than zero')\n    }\n    if (this.balance.lt(new BN(0))) {\n      throw new Error('balance must be greater than zero')\n    }\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32')\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32')\n    }\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n  raw(): Buffer[] {\n    return [\n      bnToUnpaddedBuffer(this.nonce),\n      bnToUnpaddedBuffer(this.balance),\n      this.stateRoot,\n      this.codeHash,\n    ]\n  }\n\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n  serialize(): Buffer {\n    return rlp.encode(this.raw())\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract(): boolean {\n    return !this.codeHash.equals(KECCAK256_NULL)\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty(): boolean {\n    return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(KECCAK256_NULL)\n  }\n}\n\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress)\n}\n\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (hexAddress: string, eip1191ChainId?: BNLike): string {\n  assertIsHexString(hexAddress)\n  const address = stripHexPrefix(hexAddress).toLowerCase()\n\n  let prefix = ''\n  if (eip1191ChainId) {\n    const chainId = toType(eip1191ChainId, TypeOutput.BN)\n    prefix = chainId.toString() + '0x'\n  }\n\n  const hash = keccakFromString(prefix + address).toString('hex')\n  let ret = '0x'\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase()\n    } else {\n      ret += address[i]\n    }\n  }\n\n  return ret\n}\n\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BNLike\n): boolean {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress\n}\n\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from: Buffer, nonce: Buffer): Buffer {\n  assertIsBuffer(from)\n  assertIsBuffer(nonce)\n  const nonceBN = new BN(nonce)\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return rlphash([from, null]).slice(-20)\n  }\n\n  // Only take the lower 160bits of the hash\n  return rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20)\n}\n\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (from: Buffer, salt: Buffer, initCode: Buffer): Buffer {\n  assertIsBuffer(from)\n  assertIsBuffer(salt)\n  assertIsBuffer(initCode)\n\n  assert(from.length === 20)\n  assert(salt.length === 32)\n\n  const address = keccak256(\n    Buffer.concat([Buffer.from('ff', 'hex'), from, salt, keccak256(initCode)])\n  )\n\n  return address.slice(-20)\n}\n\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey: Buffer): boolean {\n  return privateKeyVerify(privateKey)\n}\n\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey: Buffer, sanitize: boolean = false): boolean {\n  assertIsBuffer(publicKey)\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]))\n  }\n\n  if (!sanitize) {\n    return false\n  }\n\n  return publicKeyVerify(publicKey)\n}\n\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey: Buffer, sanitize: boolean = false): Buffer {\n  assertIsBuffer(pubKey)\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(publicKeyConvert(pubKey, false).slice(1))\n  }\n  assert(pubKey.length === 64)\n  // Only take the lower 160bits of the hash\n  return keccak(pubKey).slice(-20)\n}\nexport const publicToAddress = pubToAddress\n\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey: Buffer): Buffer {\n  assertIsBuffer(privateKey)\n  // skip the type flag and use the X, Y points\n  return Buffer.from(publicKeyCreate(privateKey, false)).slice(1)\n}\n\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey: Buffer): Buffer {\n  return publicToAddress(privateToPublic(privateKey))\n}\n\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey: Buffer): Buffer {\n  assertIsBuffer(publicKey)\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(publicKeyConvert(publicKey, false).slice(1))\n  }\n  return publicKey\n}\n\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function (): string {\n  const addressLength = 20\n  const addr = zeros(addressLength)\n  return bufferToHex(addr)\n}\n\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  const zeroAddr = zeroAddress()\n  return zeroAddr === hexAddress\n}\n"]}