{"version":3,"file":"signature.js","sourceRoot":"","sources":["../../../../bak_node_modules/ethereumjs-util/src/signature.ts"],"names":[],"mappings":"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","sourcesContent":["import { ecdsaSign, ecdsaRecover, publicKeyConvert } from 'ethereum-cryptography/secp256k1'\nimport { BN } from './externals'\nimport { toBuffer, setLengthLeft, bufferToHex, bufferToInt } from './bytes'\nimport { keccak } from './hash'\nimport { assertIsBuffer } from './helpers'\nimport { BNLike, toType, TypeOutput } from './types'\n\nexport interface ECDSASignature {\n  v: number\n  r: Buffer\n  s: Buffer\n}\n\nexport interface ECDSASignatureBuffer {\n  v: Buffer\n  r: Buffer\n  s: Buffer\n}\n\n/**\n * Returns the ECDSA signature of a message hash.\n */\nexport function ecsign(msgHash: Buffer, privateKey: Buffer, chainId?: number): ECDSASignature\nexport function ecsign(msgHash: Buffer, privateKey: Buffer, chainId: BNLike): ECDSASignatureBuffer\nexport function ecsign(msgHash: Buffer, privateKey: Buffer, chainId: any): any {\n  const { signature, recid: recovery } = ecdsaSign(msgHash, privateKey)\n\n  const r = Buffer.from(signature.slice(0, 32))\n  const s = Buffer.from(signature.slice(32, 64))\n\n  if (!chainId || typeof chainId === 'number') {\n    // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)\n    if (chainId && !Number.isSafeInteger(chainId)) {\n      throw new Error(\n        'The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)'\n      )\n    }\n    const v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27\n    return { r, s, v }\n  }\n\n  const chainIdBN = toType(chainId as BNLike, TypeOutput.BN)\n  const v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer)\n  return { r, s, v }\n}\n\nfunction calculateSigRecovery(v: BNLike, chainId?: BNLike): BN {\n  const vBN = toType(v, TypeOutput.BN)\n\n  if (vBN.eqn(0) || vBN.eqn(1)) return toType(v, TypeOutput.BN)\n\n  if (!chainId) {\n    return vBN.subn(27)\n  }\n  const chainIdBN = toType(chainId, TypeOutput.BN)\n  return vBN.sub(chainIdBN.muln(2).addn(35))\n}\n\nfunction isValidSigRecovery(recovery: number | BN): boolean {\n  const rec = new BN(recovery)\n  return rec.eqn(0) || rec.eqn(1)\n}\n\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nexport const ecrecover = function (\n  msgHash: Buffer,\n  v: BNLike,\n  r: Buffer,\n  s: Buffer,\n  chainId?: BNLike\n): Buffer {\n  const signature = Buffer.concat([setLengthLeft(r, 32), setLengthLeft(s, 32)], 64)\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value')\n  }\n  const senderPubKey = ecdsaRecover(signature, recovery.toNumber(), msgHash)\n  return Buffer.from(publicKeyConvert(senderPubKey, false).slice(1))\n}\n\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toRpcSig = function (v: BNLike, r: Buffer, s: Buffer, chainId?: BNLike): string {\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value')\n  }\n\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n  return bufferToHex(Buffer.concat([setLengthLeft(r, 32), setLengthLeft(s, 32), toBuffer(v)]))\n}\n\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toCompactSig = function (v: BNLike, r: Buffer, s: Buffer, chainId?: BNLike): string {\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value')\n  }\n\n  const vn = toType(v, TypeOutput.Number)\n  let ss = s\n  if ((vn > 28 && vn % 2 === 1) || vn === 1 || vn === 28) {\n    ss = Buffer.from(s)\n    ss[0] |= 0x80\n  }\n\n  return bufferToHex(Buffer.concat([setLengthLeft(r, 32), setLengthLeft(ss, 32)]))\n}\n\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nexport const fromRpcSig = function (sig: string): ECDSASignature {\n  const buf: Buffer = toBuffer(sig)\n\n  let r: Buffer\n  let s: Buffer\n  let v: number\n  if (buf.length >= 65) {\n    r = buf.slice(0, 32)\n    s = buf.slice(32, 64)\n    v = bufferToInt(buf.slice(64))\n  } else if (buf.length === 64) {\n    // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n    r = buf.slice(0, 32)\n    s = buf.slice(32, 64)\n    v = bufferToInt(buf.slice(32, 33)) >> 7\n    s[0] &= 0x7f\n  } else {\n    throw new Error('Invalid signature length')\n  }\n\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    v += 27\n  }\n\n  return {\n    v,\n    r,\n    s,\n  }\n}\n\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexport const isValidSignature = function (\n  v: BNLike,\n  r: Buffer,\n  s: Buffer,\n  homesteadOrLater: boolean = true,\n  chainId?: BNLike\n): boolean {\n  const SECP256K1_N_DIV_2 = new BN(\n    '7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0',\n    16\n  )\n  const SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16)\n\n  if (r.length !== 32 || s.length !== 32) {\n    return false\n  }\n\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false\n  }\n\n  const rBN = new BN(r)\n  const sBN = new BN(s)\n\n  if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n    return false\n  }\n\n  if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexport const hashPersonalMessage = function (message: Buffer): Buffer {\n  assertIsBuffer(message)\n  const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, 'utf-8')\n  return keccak(Buffer.concat([prefix, message]))\n}\n"]}